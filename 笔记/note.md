### Java基础
#### 并发与多线程
#### 虚拟机
#### nio
#### socket

### Spring
#### spring boot
#### spring cloud
* 项目

### 知识点



### 笔记

### 算法


### 设计模式
#### 创建型
##### 简单工厂模式
* 简单工厂模式提供一个对象实例的功能，而无须关心其具体的实现。被创建的实例可以是接口，抽象类，也可以是具体的类。
* 简单工厂模式的核心是：选择实现

![简单工厂](./designpattern/simple_factory.png)

##### 工厂方法模式
* 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类。
![工厂方法模式](./designpattern/factory_method.png)
* 工厂方法模式的主要功能是让父类在不知道具体实现的情况下，完成自身的功能调用而具体的实现延迟到子类来实现。
* 工厂方法模式的本质：延迟到子类来选择实现。

##### 抽象工厂模式
* 抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。
![抽象工厂模式](./designpattern/abstract_factory.png)
* 抽象工厂模式的核心：选择产品簇的实现


##### 单例模式
* 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。
* 创建单例模式的方法
	1. 懒汉式
	2. 饿汉式
	3. 懒汉式线程安全变种
	4. 饿汉式线程安全变种
	5. 静态内部类
	6. 双重校验锁
	7. 枚举类型
* 单例模式的本质：控制实例数目

##### 生成器模式
* 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
* ![生成器模式](./designpattern/build.png)
* 生成器模式的本质：分离整体构建算法和部件构造。

##### 原型模式
* 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
![原因模式](./designpattern/prototype.png)
* 原型模式的本质：克隆生成对象

#### 行为型
##### 状态模式
* 状态设计模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
![状态模式](./designpattern/state.png)
* 状态模式的本质：根据状态来分离和选择行为。

##### 策略模式
* 定义一系列算法，把他们一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户而变化。
![策略模式](./designpattern/strategy.png)
* 策略模式的本质：分离算法，选择实现

##### 模板设计模式
* 模板方法定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使的子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
![模板方法模式](./designpattern/template_method.png)
* 模板方法模式的本质：固定算法骨架

##### 责任链模式
* 使多个对象都有机会处理请求，从而避免请求的发送者和请求者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。
![责任链模式](./designpattern/chain_of_responsibility.png)
* 责任链模式的本质：分离职责，动态组合

##### 中介者模式
* 用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立第改变他们之间的交互。
* ![中介者模式](./designpattern/mediator.png)
* 中介者模式的本质：封装交互
* 
##### 观察者模式
* 定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
* ![观察者模式](./designpattern/observer.png)
* 观察者模式的本质：触发联动


#### 结构型
##### 外观设计模式
* 外观模式为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使的这一子系统更加容易使用。
![外观模式](./designpattern/facade.png)
* 外观模式的本质：封装交互，简化调用

##### 适配器模式
* 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
![适配器模式](./designpattern/adapter.png)
* 适配器模式本质：转换匹配，复用功能

##### 享元设计模式
* 享元模式运用共享技术有效地支持大量细粒度的对象
![享元模式](./designpattern/flyweight.png)
* 享元对象的本质：分离与共享。分离的是对象状态中变的部分，共享的是对象中不变的部分。

##### 装饰模式
* 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。
![装饰模式](./designpattern/decorator.png)
* 装饰模式的核心：动态组合
* 设计原则：类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码

##### 代理模式
* 代理模式为其他对象提供一种代理以控制对这个对象的访问。
![代理模式](./designpattern/proxy.png)
* 代理模式的本质：控制对象访问。


### 项目

### redis 
* redis常用指令
* jedis

### shell

### vue

### js
* ES6异步

### github



### ...
熟悉分布式、缓存、消息、搜索等机制，有分布式系统、集群架构设计和使用经验

消息中间件 搜索引擎 分布式数据库

JIT即时编译器

