# 数据结构与算法

### 一、树
*树是一些结点的集合*

![树](https://images2015.cnblogs.com/blog/801753/201602/801753-20160212120244792-2033644242.png "树")

* 结点：树中的数据元素都称为结点。
* 根：最上面的结点称之为根。
* 父亲：结点的上层结点。
* 兄弟：具有相同父亲的结点。
* 结点的度：结点所拥有子树的个数。如B的度为3.
* 树叶：度为0的结点，也叫做终端结点。
* 分支结点：度不为0的结点，也叫作非终端结点或内部结点，图中根、A、B、C、E、G都是分支结点
* 结点的层次：从**根结点**到某个树中某个结点所经路径上吃分支树称为该结点的层次。根结点的层次规定为1，其余结点的层次等于其父亲结点的层次+1。
* 树的深度：树中结点的最大层次。图中树的深度为4。

### 二、二叉树
***二叉树是一棵树，其中每个结点都不能有多于两个子树*** 

![二叉树](https://images2015.cnblogs.com/blog/801753/201602/801753-20160212130107980-783941139.png "二叉树")

*二叉树的一个性质是 **一颗平衡二叉树的深度要比及结点个数N小得多。** 当二叉树在失衡情况下会出现一边倒情况。这种树被称为非平衡二叉树。*

![非平衡二叉树](https://images2015.cnblogs.com/blog/801753/201602/801753-20160212140430136-1893976737.png "非平衡二叉树")

### 三、二叉查询树
*使得二叉树成为二叉查询树的条件是：**对于树中的每个结点X，它的左子树中所有项都小于X，而它的右子树中所有项的值大于X，这意味着该树所有的元素可以用某种一致的方式排序。*** 

### 四、AVL树
*为了解决二叉树/二叉查询树出现失衡、一边倒情况，从而大大降低树的检索效率。*

**满足一下特征之一的树为AVL树**
* 空树。
* 每个结点的左子树和右子树的深度最多差1。

![AVL树](https://images2015.cnblogs.com/blog/801753/201602/801753-20160212143903433-1737002330.png "AVL树")

### 五、红黑树
[漫画算法：红黑树](https://blog.csdn.net/p5deyt322jacs/article/details/78433942)

[红黑树与AVL树的优缺点](https://www.jianshu.com/p/37436ed14cc6)

*红黑树是一种平衡二叉查询树，红黑树从根到叶子的最长路径不会超过最短路径的2倍。*

#### （1）、红黑树除了二叉查询树的特征外，还包括：
* 结点是红色或者黑色
* 根结点是黑色
* 每个叶子结点都是黑色的空结点（NIL结点）。
* 每个红色结点的两个子结点都是黑色
* 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

![红黑树](https://images2015.cnblogs.com/blog/801753/201602/801753-20160213135100949-2011378248.png "红黑树")

#### （2）、红黑树的优势
*相比AVL树，红黑树在检索时候的效率几乎是差不多的，都是通过平衡二叉查找法。**但是对于插入删除操作的效率提高很多。***

### 六、B-Tree、B+Tree
[B-Tree、B+-Tree](https://www.cnblogs.com/suixinpeng/p/b-tree.html)

(https://www.cnblogs.com/vincently/p/4526560.html)

[B树、B+树的插入与删除图文详解](https://www.cnblogs.com/nullzx/p/8729425.html)

#### （1）、B-Tree

*B-Tree是一个多路平衡查找树，它的，每个结点最多包含m个孩子，m为B树的阶。m的大小取决于磁盘页的大小。*

##### 一个m阶的B树具有如下几个特征：ceil()向上取整
* 树中每个结点至多有m个孩子；
* 除根结点和叶子结点外，其他结点最少有ceil(m/2)个子结点。
* 若根结点不是叶子结点，则最少有两个子结点。
* 每个结点最多有m-1个关键字key，非根结点最少有Math.ceil(m/2)-1个key，根结点最少有1个关键字。
* 所有叶子结点都位于同一层。
* 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

**B树中每个结点存储关键字key和关键字对应的数据(data)，在数据库中，B树中的key表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。**

![B树](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png "B树")

##### B树的插入操作

*当向B树中插入一个键值对（key,value）时，如果B树中已经存在，则用新的value替换旧的value。如果不存在key，则一定在叶子结点进行插入操作。*

* 根据要插入的key的值，找到叶子结点并插入。
* 判断当前结点的key的个数是否小于等于m-1，若满足则结束，否则进行下一步。
* 以结点中间的key为中小分裂成左右两部分。然后将这个中间的key插入到父结点中，左右两部分分别为父结点的左右子结点。（如果阶数m为偶数，那么选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可）

##### B树的删除操作

* 如果B树中的记录中不存对应key的记录，则删除失败
* 如果需要删除的key位于非叶子结点，则用后继key替换要删除的key。然后转变为删除后继key，后继key必定在叶子结点上。
* 如果删除key所在的结点的key个数大于等于Math.ceil(m/2)-1，结束操作，否则进行下一步。
* 如果兄弟结点的key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。
* 否则父结点的key下移一个，与当前结点及它的兄弟结点中的key合并，形成一个新的结点。（有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可）

#### （2）、B+Tree
![B+树](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232854940-1019144331.png "B+树")

对于一个m阶B+树与m阶B树的不同点：
* B+树中包含2种类型的结点：内部结点（索引结点）、叶子结点。根节点即可以是内部结点，也可以是叶子结点。
* 内部结点不保存数据，只保存索引，索引数据都保存在叶子结点中。
* 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。
* 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。

##### B+树的插入操作
* 若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。
* 针对叶子类型结点：插入后若当前结点的key的个数小于等于m-1，则操作结束。否则将这个结点分裂成左右两个叶子结点，**小于**中间key的记录放在左结点，**大于等于**中间key的记录放在右结点。将中间key进位到父结点中（索引结点）。
* 针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，**小于**中间key的记录放在左索引结点，**大于**中间key的记录放在右索引结点，将中间key进位到父结点中。

##### B+树的删除操作
* 如果叶子结点中没有相应的key，则删除失败
* 删除叶子结点中对应的key。删除后若结点中key的个数大于等于Math.ceil(m/2) – 1，删除操作结束。否则进行下一步。
* 若兄弟结点key的个数大于Math.ceil(m/2) – 1，向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则进行下一步。
* 若兄弟结点key的个数小于等于Math.ceil(m/2) – 1，则将当前结点和兄弟结点合并为一个新的叶子结点，并删除父结点中的key。
* 如果父索引结点key的个数大于等于Math.ceil(m/2) – 1，删除操作结束。否则进行下一步。
* 若索引结点的兄弟结点key的个数大于Math.ceil(m/2) – 1，父结点的key下移，兄弟结点的key上移，删除结束。
* 若索引结点的兄弟结点key的个数小于等于Math.ceil(m/2) – 1，当前结点和兄弟结点及父结点下移key合并成一个新的结点。

**注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。**

#### （3）、B树与B+树的优缺点
*  B+树的磁盘读写代价更低：B+树的内部结点只存key，没有执行key的具体信息指针。因此内部结点相对B树更小，把同一内部结点的key存放在同一盘块中，B+树存放key的越多，IO读写次数也就降低了。
*  B+树的数据信息遍历更加方便：B+树只要遍历叶子节点就可以实现整棵树的遍历，B树效率太低。而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树。
*  B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
*  B树的优势是当你要查找的值恰好处在一个非叶子结点时，查找到该节点就会成功并结束查询。而B+树的记录存放在叶子结点。
