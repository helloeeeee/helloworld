# 多线程

### 一、创建多线的三种方式
* 继承Thread类，重写run方法。
* 实现Runnable接口。通过一个Thread来启动。
* 创建FutureTask对象（此对象实现了Runnable接口、Future接口），传入Callable接口实现类到FutureTask（装饰模式）。通过一个Thread来启动，执行FutureTask对象的run方法（实际上执行的是Callable的run方法）。**此方法本质还是实现Runnable接口。通过一个Thread来启动。只不过可以得到返回结果**

### 二、对比继承Thread类和实现Runnable接口的区别
* 其实Thread类也是实现的Runnable接口。
* Thread是线程启动者，Runnbale是任务。当调用start方法时，会创建并启动一个线程，此线程执行run任务。
* 继承只能单继承，实现可以多实现。
* 实现的方式对比继承的方式，也有利于减小程序之间的耦合。

### 三、线程状态（java.lang.Thread.State 六种）
**新建、可运行、阻塞、等待、带超时的等待、终止**

[线程状态转换](https://www.zhihu.com/question/27654579)

![线程状态转换图](https://pic4.zhimg.com/v2-6fdc939e35ec801c31ea515e80a88367_r.jpg "线程状态转换图")

Thread.join()

#### 新建状态New。
    (new Thread(),new了但是没有启动的线程状态)
#### 可运行状态RUNNABLE（包括运行态和就绪态）。
##### 就绪态
* 该状态下的线程已经获得执行所需的所有资源，等待CPU分配执行权。
* 所有就绪状态的线程都存放在就绪队列中。

##### 运行态
* 获取到CPU的执行权，正在执行的线程。
* 由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。

#### 阻塞BLOCKED。 
* 当一个正在执行的线程请求某一个资源失败时（**锁、IO、Socket等**），就会进入阻塞状态。
* 在java中，阻塞态专指请求锁失败时的状态。
* 所有阻塞态的线程都存放在阻塞队列中。
* 处于阻塞态的线程会不断的请求资源，一旦请求成功，就会进入就绪状态，等待执行

#### 等待WAITING。
* 当运行的线程调用wait、join、park函数时，当前线程进入到等待态。
* 并不是因为请求不到资源，而是主动进入。
* 所有等待态的线程都存放在等待队列中。（等待池）
* 线程处于等待态表示需要等待其他线程的指示才能继续运行，**进入就绪状态**。
* 进入等待态的线程会释放CPU执行权和资源（如：锁）。

#### 超时等待TIMED_WAITING。
* 当运行的线程调用wait(time)、join(time)、parkNanos、parkUntil、sleep(time)时，会进入该状态。
* 它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒，或者到了超时时间后自动进入**就绪状态，然后等待CPU分配资源，进入运行状态，开始竞争锁**。
* 进入该状态后释放CPU执行权 ，释放占有的资源(sleep除外)。
* 到了超时时间后自动进入**就绪状态**（**sleep除外，sleep到时进入运行态**），开始竞争锁。

#### 终止状态TERMINATED
    线程执行结束后的状态。

#### 注意
* wait方法会释放CPU占有权和资源。
* sleep方法仅释放CPU占有权，不会释放资源，锁仍然被占用。线程被放入超时等待状态，与yield相比，它会使线程较长时间得不到运行。
* yield方法仅释放CPU占有权，不会释放资源，锁仍然被占用。线程会被放入就绪队列，会在短时间内再次执行。
* wait和notify必须配套使用，即必须使用同一把锁调用，且必须是他们所处同步块的锁对象。
* wait和notify必须放在一个同步块中。

### 四、参考博客
[Java并发性和多线程介绍目录](http://ifeve.com/java-concurrency-thread-directory/)

[五月的仓颉的多线程](https://www.cnblogs.com/xrq730/category/733883.html)

[多线程、多核cpu问题](https://blog.csdn.net/nalanmingdian/article/details/77748326)

***单CPU在同一时间点是只能执行一条线程***

#### 理解多线程、多核cpu问题
![操作系统原生线程模型](https://img-blog.csdn.net/20180823203548296?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwMTczNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70 "操作系统原生线程模型")

##### 名词解释
* **KLT**:内核线程，直接由操作系统内核支持的线程。
* **LWP**:轻量级进程，通常意义上的线程
* **Thread Scheduler**:线程调度器（系统为线程分配处理器使用权的过程，线程切换）

##### 运行原理
*1、操作系统内核通过线程调度器对内核线程进行调度，并负责将内核线程的任务映射到各个处理器上。*

*2、程序P一般不会直接去使用内核线程，而是使用内核线程的一种高级接口：轻量级进程（**LWP，也就是通常意义的线程，本人理解为java多线程中的start0方法**）。轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。*


##### 线程调度器
*线程调度器主要调度方式有两种：**协同式线程调度、抢占式线程调度***

* 协同式线程调度：线程的执行时间有线程本身来控制，线程执行完后，要主动通知系统切换到另一个线程上。
* 抢占式线程调度：每个线程的执行由系统来分配，不由线程本身决定。

**好处**

* 协同式线程调度：(1)实现简单。(2)线程没有同步问题。由于线程把自身任务执行完才会进行线程切换。
* 抢占式线程调度：(1)线程的执行时间是系统可控的。(2)不会因为有一个线程导致整个进程阻塞的问题。

**坏处与好处相反**