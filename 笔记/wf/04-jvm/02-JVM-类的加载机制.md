# JVM
[JVM系列](https://www.cnblogs.com/ityouknow/category/437541.html)

[面试题-JVM](https://blog.csdn.net/gangsijay888/article/details/81331423)

### java类的加载机制
![java程序执行过程](https://images0.cnblogs.com/i/288799/201405/281630330728961.jpg "java程序执行过程")
### 一、类的加载
* java源代码文件（.java后缀）被java编译器编译成字节码文件（.class文件）。
* JVM类加载器将字节码文件的二进制数据读入到JVM内存（运行时数据区）的方法区。
* 在堆区创建一个java.lang.class对象，用了封装类在方法区的数据结构。
* 加载的数据交由JCM执行引擎执行。

### 二、类的生命周期
![类的生命周期](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png "类的生命周期")
*类的加载过程包括：**加载、验证、准备、解析、初始化**五个阶段。这几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段（交替执行）。*

#### （1）加载
*查找并加载类的二进制数据*

* 根据类的全限定名来获取其定义的二进制字节流
* 将二进制字节流的静态存储结构转换为方法区的数据结构
* 在Java堆中创建一个代表这个类的Class对象，作为访问方法区中数据的入口

#### （2）验证
*确保被加载的类的正确性*

##### （3）准备
*为类的 **静态变量**分配内存，并将其初始化为默认值。**准备阶段是为类变量正式分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。***

* 分配内存的变量仅仅是类变量(static)，不包括实例变量，实例变量在对象实例化时，随着对象一起分配到Java堆内存中。
* 假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法。而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。**总结：初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。**
* 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

  假设上面的类变量value被定义为： public static final int value = 3；

  编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。即**static final常量在编译期就将其结果放入了调用它的类的常量池中**

**注意：**
* 对基本类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值（**类变量在类加载时期，全局变量在对象初始化时期**）。而对于局部变量，在使用前必须显式地为其赋值，否则编译时不通过。
* 被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过（final修饰符修饰的变量表示不可以被二次赋值，且系统不会给其赋默认值。）；
* 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
* 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

#### （4）解析
*这一阶段的任务就是把常量池中的符号引用转换为直接引用，说白了就是jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。*

#### （5）初始化
*这个阶段就是将静态变量（类变量）赋值的过程，即只有static修饰的才能被初始化*

JVM初始化步骤
* 假如这个类还没有被加载和连接，则程序先加载并连接该类
* 假如该类的直接父类还没有被初始化，则先初始化其直接父类
* 假如类中有初始化语句，则系统依次执行这些初始化语句

**即：父类静态域或着静态代码块，然后是子类静态域或者子类静态代码块**

#### （6）结束生命周期
在如下几种情况下，Java虚拟机将结束生命周期
* 执行了System.exit()方法
* 程序正常执行结束
* 程序在执行过程中遇到了异常或错误而异常终止
* 由于操作系统出现错误而导致Java虚拟机进程终止

### 三、类加载器
![类加载器](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125944459-1013316302.jpg "类加载器")

* **启动类加载器：** Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
* **扩展类加载器：** Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
* **应用类加载器：** Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 四、类的加载 
**类的加载方式**
* 命令行启动应用时候由JVM初始化加载
* 通过Class.forName()方法动态加载
* 通过ClassLoader.loadClass()方法动态加载

**Class.forName()和ClassLoader.loadClass()区别**
* Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
* ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

### 五、双亲委派模型
*双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。*

* 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
* 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
* 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
* 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

双亲委派模型意义：
* 系统类防止内存中出现多份同样的字节码
* 保证Java程序安全稳定运行
* 要确定某一个类，需要类的全限定名以及加载此类的ClassLoader来共同确定。也就是说即使两个类的全限定名是相同的，但是因为不同的ClassLoader加载了此类， 那么在JVM中它是不同的类。所以避免了不同的类加载器加载了同样名字的不同类以后造成混乱