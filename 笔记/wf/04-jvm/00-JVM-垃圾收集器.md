# GC 垃圾收集器
*在JVM中，程序计数器、本地方法栈、虚拟机栈的内存都是随着线程结束而清理，栈帧随着方法的进入和退出而入栈、出栈。**内存垃圾回收主要集中在Java对内存和方法区中。***

### 一、判断对象存活
* 引用计数：每个对象都有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。**无法解决对象间相互循环引用的问题。**
* 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径成为引用链。当一个对象到GC Roots没有任何引用链相连时，这个对象是不可用的。不可达对象。

*在Java语言中，GC Roots包括：**1、虚拟机栈中引用的对象。2、方法区中类静态属性实体引用对象。3、方法区中常量引用的对象。4、本地方法栈中JNI引用的对象。***

### 二、强、软、弱、虚引用
#### （1）、强引用
*new对象时被引用，该对象具有强引用。在对象生命周期内，当内存空间不足时，JVM宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。*

#### （2）、软引用（new SoftReference<>(obj)）
*在对象生命周期内，如果一个对象具有软引用，当内存不足时，JVM就会回收对象对此。当内存足够时，JVM不会回收对象内存。*

#### （3）、弱引用（new WeakReference<>(obj)）
*在对象生命周期内，如果一个对象具有弱引用，不管当前内存空间足够与否，都会回收对象的内存。*

#### （4）、虚引用（new PhantomReference<>()）
*声明虚引用的时候是要传入一个ReferenceQueue的。当虚引用所引用的对象已经执行完finalize函数的时候，就会把改该对象加到queue里面。可以通过判断queue里面是不是有该对象来判断该对象是不是要被回收了。**虚引用用来对象被回收之前执行操作。***

### 三、垃圾收集算法
[垃圾收集算法](https://www.cnblogs.com/java-zhao/p/5183261.html)

#### （1）、标记-清除算法
*GC Roots判断垃圾对象时，将存活对象标记，最后扫描整个内存空间并清除没有标记的对象。*

**适用场景：**
* 存活对象较多的情况下比较高效。
* 适用于老年代。

**缺点：**
* 容易产生内存碎片。
* 扫描整个内存空间两次（第一次：标记存活对象。第二次：清除没有标记的对象）

#### （2）、标记-整理算法
*针对标记-删除算法会产生内存碎片的缺点。基于标记-删除算法，GC Roots判断垃圾对象时，将存活对象标记，并移动到内存的一端，超出边界线的内存对象为不可达对象，进行回收。*

**适用场景：**
* 适用于老年代。

**缺点：**
* 需要移动对象。如果需要移动的对象多，效率会低。
* 扫描整个内存空间两次（第一次：标记存活对象。第二次：清除没有标记的对象）

**优点：**
* 不会产生内存碎片。

#### （3）、复制算法
*将内存分为两份，每次只使用其中一块。当这一块的内存用完了，GC Roots判断垃圾对象时，将存活对象标记，并移动到另一份内存中，然后再把已使用过的内存空间一次清理掉。*

**适用场景：**
* 适用于年轻代。基本上80%的对象是“朝生夕死的”。
* 存活对象较少的情况下。

**缺点：**.
* 浪费内存空间，因为总有一份不会被存储对象。
* 需要复制移动对象。

**优点：**
* 不会产生内存碎片。
* 只扫描一次内存空间（标记存活对象并复制移动对象。）

#### （4）、分代收集算法
[分代收集算法](https://blog.csdn.net/sinat_36246371/article/details/52998505)

* JVM将堆内存分为 **年轻代和老年代。**其中**年轻代分为Eden、两个Survivor区（From、To），比例为8:1:1。**
* 当系统新建一个对象时，对象存放在Eden区，当这个区慢了，就会触发一次Young GC（年轻代的垃圾回收）。
* 将存活对象复制到From区。将Eden区清理干净。
* 继续新建对象，当Eden区被用完时，再次出发Young GC，将Eden区和From区的存活对象复制到To区。将Eden区和From区清理干净。
* 依次触发Young GC时，存活对象在From区和To区来回游荡。
* 当存活对象所在的Survivor区到达阈值时，将依然存活的对象复制到老年代区。
* 当老年代区也到达阈值时，会进行Full GC回收，对整个堆进行整理。

**注意：1、总有一个Survivor区是空的。2、尽量减少Full GC的操作（JVM调优）**

### 四、垃圾收集器
[垃圾收集器](https://www.cnblogs.com/FishAndWater/p/4126855.html)

#### （1）、Serial收集器（年轻代-串行GC）
*单线程GC收集器，在进行垃圾收集的时候，其他工作线程暂停(**Stop The World**)，采用复制算法。*

**优点：简单高效，没有额外的线程交互的开销。**

![Serial与Serial Old收集器](https://images2017.cnblogs.com/blog/587852/201707/587852-20170730180624849-1225528282.png "Serial与Serial Old收集器")

#### （2）、ParNew收集器（年轻代-并行GC）
*Serial收集器的多线程版本，采用复制算法。*

**优点：在多CPU的环境下可以发挥更高而效率，并且是唯一一个可以和CMS收集器搭配工作的新生代并行GC。**

![ParNew与Serial Old收集器](https://images2017.cnblogs.com/blog/587852/201707/587852-20170730180727896-1979758780.png "ParNew与Serial Old收集器")

#### （3）、Parallel Scavenge收集器（年轻代-并行GC）
*Parallel Scavenge最大的特点就是他的关注点在于CPU的吞吐量，吞吐量=运行代码时间/（运行代码时间+垃圾收集时间）。较高的吞吐量可以最好的利用CPU的效率。采用复制算法。*

**优点：吞吐量较高。**

#### （4）、Serial Old收集器（老年代-串行GC）
*Serial收集器的老年代版本，单线程收集器。采用标记-整理算法。*

#### （5）、Parallel Old收集器（老年代-并行GC）
*Parallel的老年代版本，为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合。采用标记-整理算法。*

![Parallel Scavenge与Parallel Old收集器](https://images2017.cnblogs.com/blog/587852/201707/587852-20170730180953162-1772877339.png "Parallel Scavenge与Parallel Old收集器")

#### （6）、CMS收集器（老年代-并行GC）
*采用标记-清除，整个过程分为4个：**初始标记、并发标记、重新标记、并发清除。其中初始标记和重新标记是Stop The World，会导致工作线程暂停。** 初始标记仅仅是标记一下GC Roots能直接关联的对象，并发标记进行GC Roots Tracing的过程，重新标记为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那部分对象，这个阶段停顿时间比初始标记阶段稍长一些，但比并发标记时间短。*

**优点：并发收集、低停顿。**

**缺点：会产生内存碎片。**

![CMS收集器](https://images2017.cnblogs.com/blog/587852/201707/587852-20170730181100724-1830461185.png "CMS收集器")

#### （7）、G1收集器（老年代-并行GC）
*采用标记整理算法，不会产生内存碎片。*

**与CMS相比，优点：**
* 采用标记整理算法，不会产生内存碎片
* 可预测停顿，使用者可以明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

![G1收集器](https://images2017.cnblogs.com/blog/587852/201707/587852-20170730181159459-572961282.png "G1收集器")